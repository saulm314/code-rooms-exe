@page "/"
@inject IJSRuntime Js
@inject HttpClient Http
@using CREBlazorApp.GeneratedCode
@using CRECSharpInterpreter
@using CRECSharpInterpreter.Levels
@using Newtonsoft.Json
@using Environment = CRECSharpInterpreter.Environment
@using Variable = CRECSharpInterpreter.Variable

<PageTitle>CodeRooms.exe</PageTitle>

@foreach (string imageSource in _preloadedImageSources)
{
	<link rel="preload" as="image" href="@(_imageSourceDirectory + imageSource)"/>
}

<div id="background-grid" class="variable-font-size">
<div id="foreground">

<div id="stack-container">
	<div id="stack-label-container">
		<label id="stack-label">Stack</label>
	</div>
	<div id="stack-contents-scroll-container">
		<div id="stack-contents-container">
			@for (int i = 0; i < _stackVariables.Count; i++)
			{
				StackVarInfo stackVarInfo = _stackVariables[i];
				VarInfo varInfo = stackVarInfo.PVarInfo;
				<div
					class="stack-entry"
					style="grid-row: @(2 * i + 1);"
				>
					<div class="var-container">
						<img class="var-image" src="@varInfo.ImageSource"/>
						<div
							class="var-value-container"
							style="
								font-size: @(varInfo.FontSize)px;
								font-weight: @(varInfo.IsBold ? "bold" : "normal");
								color: @(varInfo.IsBlack ? "black" : "white");
								padding-top: @(varInfo.PaddingTop)px;
								padding-bottom: @(varInfo.PaddingBottom)px;
								padding-left: @(varInfo.PaddingLeft)px;
								padding-right: @(varInfo.PaddingRight)px;
								align-items: @varInfo.HorizontalAlignment;
								justify-content: @varInfo.VerticalAlignment;
							"
						>
							<label>@varInfo.Value</label>
						</div>
					</div>
					<label class="var-name" style="font-size: @(stackVarInfo.FontSize)px;">@stackVarInfo.Name</label>
				</div>
				<div
					class="stack-separator"
					style="grid-row: @(2 * i + 2);"
				>
					<div
						class="stack-separator-solid"
						style="background-color: @stackVarInfo.SeparatorColor"
					></div>
				</div>
			}
		</div>
	</div>
</div>

<div id="main-grid">
	<div id="text-editor-container">
		<textarea id="text-editor" @bind="_textEditorText" disabled="@(_textEditorDisabled || _viewingSolution)" spellcheck="false"/>
	</div>
	<div id="description-container">
		<textarea id="description" @bind="_descriptionText" readonly></textarea>
	</div>
	<div id="heap-idecontrols-container">
		<div id="heap-container">
			<div id="heap-label-container">
				<label id="heap-label">Heap</label>
			</div>
			<div id="heap-contents-scroll-container">
				<div id="heap-grid">
					@for (int y = 0; y < _heapCapacity / 10; y++)
					{
						@for (int x = 0; x < 10; x++)
						{
							int index = 10 * y + x;
							<div
								class="heap-entry"
								style="grid-column: @(2 * x + 2); grid-row: @(2 * y + 2);"
							>
								@if (index < _heapVariables.Count && _heapVariables[index] != null)
								{
									VarInfo varInfo = (VarInfo)_heapVariables[index]!;
									<div class="var-container">
										<img class="var-image" src="@varInfo.ImageSource"/>
										<div
											class="var-value-container"
											style="
												font-size: @(varInfo.FontSize)px;
												font-weight: @(varInfo.IsBold ? "bold" : "normal");
												color: @(varInfo.IsBlack ? "black" : "white");
												padding-top: @(varInfo.PaddingTop)px;
												padding-bottom: @(varInfo.PaddingBottom)px;
												padding-left: @(varInfo.PaddingLeft)px;
												padding-right: @(varInfo.PaddingRight)px;
												align-items: @varInfo.HorizontalAlignment;
												justify-content: @varInfo.VerticalAlignment;
											"
										>
											<label>@varInfo.Value</label>
										</div>
									</div>
								}
							</div>
							<div
								class="heap-index-container"
								style="grid-column: @(2 * x + 2); grid-row: @(2 * y + 3);"
							>
								<label class="heap-index-label">@(index == 0 ? "null" : index)</label>
							</div>
						}
					}
				</div>
			</div>
		</div>
		<div id="ide-controls-container">
			<button id="compile-button" @onclick="OnCompilePressed" disabled="@_compileButtonDisabled">Compile</button>
			<button id="edit-button" @onclick="OnEditPressed" disabled="@_editButtonDisabled">Edit</button>
			<button id="run-button" @onclick="OnRunPressed" disabled="@_runButtonDisabled">Run</button>
			<div id="arrow-buttons-container">
				<button class="arrow-button" @onclick="OnLeftPressed" disabled="@_leftButtonDisabled">&lt;</button>
				<button class="arrow-button" @onclick="OnRightPressed" disabled="@_rightButtonDisabled">&gt;</button>
			</div>
			<button id="next-button" @onclick="OnNextPressed" disabled="@_nextButtonDisabled">Next</button>
		</div>
	</div>
	<div id="output-container">
		<textarea id="output" readonly @bind="_outputText">Output</textarea>
	</div>
	<div id="menu-container" class="variable-font-size">
		<div id="level-select-container">
			<div id="level-select-grid" class="variable-font-size">
				@if (_levels.Length > 0)
				{
					<button class="level-button" @onclick="() => OnLevelPressed(0)">@_levels[0].name</button>
				}
				@for (int i = 1; i < _levels.Length; i++)
				{
					Level level = _levels[i];
					LevelSave levelSave = _save.levelSaves[i];
					string blanks = Utils.GetSpaces(8 + level.id.ToString().Length);
					<button class="level-button" @onclick="() => OnLevelPressed(level.id)" disabled="@(i > 1 && _save.levelSaves[i - 1].starsCollected < 1)">
						<div class="level-button-label">Level @level.id: @level.name</div>
						<div class="level-button-label">@blanks@levelSave.starsCollected/@level.maxStars ⭐</div>
					</button>
				}
			</div>
		</div>
		<div id="menu-bottom-bar-grid">
			<div id="total-stars-display-container" class="variable-font-size">
				<label class="total-stars-label">Total:</label>
				<label id="total-stars-label" class="total-stars-label">@_totalStarsCollected/@_totalStarsAvailable ⭐</label>
			</div>
			<button id="syntax-button" @onclick="OnSyntaxPressed" disabled="@_syntaxButtonDisabled">Current Syntax: @_syntax</button>
			<button
				id="solution-button"
				@onclick="OnSolutionPressed"
				style="--background-color: @(_currentLevel == 0 ? _solutionButtonResetColor : _solutionButtonSolutionColor);"
			>
				@(_currentLevel == 0 ? (_resetInitiated ? "Cancel" : "Reset Progress") : (_viewingSolution ? "Back" : "See Solution"))
			</button>
		</div>
	</div>
</div>

</div>
</div>

@code {
	private const string _imageSourceDirectory = "Files/Types/";
	private const string _solutionButtonResetColor = "rgb(82, 0, 13)";
	private const string _solutionButtonSolutionColor = "rgb(102, 57, 5)";

	private string[] _preloadedImageSources = GeneratedImageSources.ImageSources;
	private List<StackVarInfo> _stackVariables = [];
	private string _textEditorText = DefaultStrings.TextEditor;
	private bool _textEditorDisabled = false;
	private string _descriptionText = string.Empty;
	private int _heapCapacity = 50;
	private List<VarInfo?> _heapVariables = [];
	private bool _compileButtonDisabled = false;
	private bool _editButtonDisabled = true;
	private bool _runButtonDisabled = true;
	private bool _leftButtonDisabled = true;
	private bool _rightButtonDisabled = true;
	private bool _nextButtonDisabled = true;
	private bool _syntaxButtonDisabled = false;
	private string _outputText = string.Empty;
	private Level[] _levels = [];
	private int _totalStarsAvailable = 0;
	private Save _save = new();
	private int _totalStarsCollected = 0;
	private string _syntax = "C#";
	private int _currentLevel = 0;
	private bool _resetInitiated = false;
	private bool _viewingSolution = false;

	public Interpreter? PInterpreter { get; private set; }

	public static MemoryFrame Frame => Memory.Instance!.Frames[Memory.Instance.CurrentFrame];

	public LevelManager? PLevelManager { get; private set; }

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();
		if (Http.DefaultRequestHeaders.CacheControl == null)
			Http.DefaultRequestHeaders.CacheControl = new();
		Http.DefaultRequestHeaders.CacheControl.NoCache = true;
		PLevelManager = await LevelManagerHandler.NewLevelManager(Http);
		_levels = PLevelManager.Levels;
		_totalStarsAvailable = _levels.Sum(level => level.maxStars);
		LoadLevel(0);
		_save = await GetSaveAsync();
		_totalStarsCollected = _save.levelSaves.Sum(levelSave => levelSave.starsCollected);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		await base.OnAfterRenderAsync(firstRender);
		if (firstRender)
		{
			await Js.AddNewlineIndentEventListener("text-editor");
			await Js.AddTextEditorCurlyBraceEventListener("text-editor");
			await Js.AddTextEditorTabEventListener("text-editor");
		}
		await Js.ScrollToBottom("stack-contents-scroll-container");
		await Js.ScrollToBottom("heap-contents-scroll-container");
	}

	private void LoadLevel(int id, int cycle = 0)
	{
		_currentLevel = id;
		PLevelManager!.LoadLevel(id, cycle);
		_descriptionText = PLevelManager.GetLevel(id).Description ?? string.Empty;
	}

	private async Task<Save> GetSaveAsync()
	{
		string? storedSaveJson = await Js.GetLocal<string?>("save");
		Save save;
		string saveJson;
		if (storedSaveJson == null)
		{
			save = new(_levels.Length);
			saveJson = JsonConvert.SerializeObject(save);
			await Js.SetLocal<string>("save", saveJson);
			return save;
		}
		Save storedSave = JsonConvert.DeserializeObject<Save>(storedSaveJson)!;
		if (storedSave.levelSaves.Length < _levels.Length)
		{
			save = new(_levels.Length);
			storedSave.levelSaves.CopyTo(save.levelSaves, 0);
			saveJson = JsonConvert.SerializeObject(save);
			await Js.SetLocal<string>("save", saveJson);
			return save;
		}
		save = new(_levels.Length);
		Array.Copy(storedSave.levelSaves, save.levelSaves, save.levelSaves.Length);
		saveJson = JsonConvert.SerializeObject(save);
		await Js.SetLocal<string>("save", saveJson);
		return save;
	}

	private async Task UpdateSaveAsync(Save save)
	{
		string saveJson = JsonConvert.SerializeObject(save);
		await Js.SetLocal<string>("save", saveJson);
	}

	private async Task UpdateSolutionIfEmptyOrHasErrorAsync(bool hasError = true)
	{
		int level = PLevelManager!.CurrentLevel;
		if (level == 0)
			return;
		if (string.IsNullOrWhiteSpace(_textEditorText))
			return;
		if (_viewingSolution)
			return;
		if (_save.levelSaves[level].solution != string.Empty && !_save.levelSaves[level].hasError)
			return;
		_save.levelSaves[level].solution = _textEditorText;
		_save.levelSaves[level].hasError = hasError;
		await UpdateSaveAsync(_save);
	}

	private async Task UpdateSolutionIfEmptyOrZeroStarsAsync(bool hasError = false)
	{
		int level = PLevelManager!.CurrentLevel;
		if (level == 0)
			return;
		if (string.IsNullOrWhiteSpace(_textEditorText))
			return;
		if (_viewingSolution)
			return;
		if (_save.levelSaves[level].solution != string.Empty && _save.levelSaves[level].starsCollected != 0)
			return;
		_save.levelSaves[level].solution = _textEditorText;
		_save.levelSaves[level].hasError = hasError;
		await UpdateSaveAsync(_save);
	}

	private async Task UpdateSolutionIfEqualOrGreaterStarsAsync(bool hasError = false)
	{
		int level = PLevelManager!.CurrentLevel;
		if (level == 0)
			return;
		if (string.IsNullOrWhiteSpace(_textEditorText))
			return;
		if (_viewingSolution)
			return;
		if (_save.levelSaves[level].starsCollected > _minStars)
			return;
		_save.levelSaves[level].starsCollected = _minStars;
		_save.levelSaves[level].solution = _textEditorText;
		_save.levelSaves[level].hasError = hasError;
		await UpdateSaveAsync(_save);
		_totalStarsCollected = _save.levelSaves.Sum(levelSave => levelSave.starsCollected);
	}

	private async Task ResetSaveAsync()
	{
		await Js.RemoveLocal("save");
		_save = await GetSaveAsync();
		StateHasChanged();
	}

	private int _currentCycle = 0;
	private int _minStars = int.MaxValue;
	public void OnCompilePressed()
	{
		_compileButtonDisabled = true;
		_editButtonDisabled = false;
		_runButtonDisabled = false;
		_syntaxButtonDisabled = true;
		_textEditorDisabled = true;
		OutputClear();
		OutputWriteLine("Compiling...");
		LoadLevel(PLevelManager!.CurrentLevel, _currentCycle);
		try
		{
			PInterpreter = new(_textEditorText);
			OutputWriteLine("Compilation successful");
			_ = UpdateSolutionIfEmptyOrZeroStarsAsync();
		}
		catch (InterpreterException exception)
		{
			OutputWriteLine(exception.Message);
			_runButtonDisabled = true;
			_ = UpdateSolutionIfEmptyOrHasErrorAsync();
		}
		catch (Exception exception)
		{
			OutputWriteLine("Error, possibly internal:");
			OutputWriteLine(exception);
			_runButtonDisabled = true;
			_ = UpdateSolutionIfEmptyOrHasErrorAsync();
		}
	}

	public void OnEditPressed()
	{
		_editButtonDisabled = true;
		_compileButtonDisabled = false;
		_runButtonDisabled = true;
		_leftButtonDisabled = true;
		_rightButtonDisabled = true;
		_nextButtonDisabled = true;
		_syntaxButtonDisabled = false;
		_textEditorDisabled = false;
		ClearStack();
		ClearHeap();
		CancelReset();
		_currentCycle = 0;
		_minStars = int.MaxValue;
	}

	public void OnRunPressed()
	{
		_runButtonDisabled = true;
		_rightButtonDisabled = false;
		_leftButtonDisabled = !Frame.CanMoveLeft;
		_rightButtonDisabled = !Frame.CanMoveRight;
		DisplayFrame();
		OutputWriteLine("Running...");
	}

	public void OnLeftPressed()
	{
		PInterpreter!.MoveLeft();
		_leftButtonDisabled = !Frame.CanMoveLeft;
		_rightButtonDisabled = !Frame.CanMoveRight;
		DisplayFrame();
		CancelReset(true);
	}

	public void OnRightPressed()
	{
		PInterpreter!.MoveRight();
		_leftButtonDisabled = !Frame.CanMoveLeft;
		_rightButtonDisabled = !Frame.CanMoveRight;
		DisplayFrame();

		if (Memory.Instance!.CurrentFrame == 1)
			ResetIfConditionsMet();

		if (Frame.CanMoveRight)
			return;
		ILevelTest levelTest = PLevelManager!.GetLevelTest();
		int starsAchieved = levelTest.StarsAchieved(_currentCycle);
		if (starsAchieved > 0)
		{
			OutputWriteLine($"Pass with {starsAchieved} stars");
			_nextButtonDisabled = false;
			_minStars = starsAchieved < _minStars ? starsAchieved : _minStars;
			return;
		}
		if (PLevelManager.CurrentLevel != 0)
			OutputWriteLine("Fail");
	}

	public void OnNextPressed()
	{
		_nextButtonDisabled = true;
		_leftButtonDisabled = true;
		_currentCycle++;
		if (_currentCycle >= PLevelManager!.GetCycleCount())
		{
			OutputWriteLine($"All passed with {_minStars} stars; next level unlocked");
			_ = UpdateSolutionIfEqualOrGreaterStarsAsync();
			return;
		}
		OutputWriteLine("Running next...");
		OnCompilePressed();
		OnRunPressed();
	}

	public void OnLevelPressed(int level)
	{
		_textEditorText = level == 0 ? DefaultStrings.TextEditor : _save.levelSaves[level].solution;
		CancelReset();
		_viewingSolution = false;
		OnEditPressed();
		LoadLevel(level);
		_ = Js.ScrollToTop("description");
	}

	public void OnSyntaxPressed()
	{
		Environment._Syntax = Environment._Syntax switch
		{
			Syntax.CSharp => Syntax.Java,
			Syntax.Java => Syntax.CSharp,
			_ => Syntax.CSharp
		};
		_syntax = Environment._Syntax switch
		{
			Syntax.CSharp => "C#",
			Syntax.Java => "Java",
			_ => string.Empty
		};
	}

	public void OnSolutionPressed()
	{
		if (PLevelManager!.CurrentLevel == 0)
			OnResetPressed();
		else
			OnActualSolutionPressed();
	}

	public void OnResetPressed()
	{
		if (_resetInitiated)
		{
			CancelReset();
			return;
		}
		_resetInitiated = true;
		OutputWriteLine("WARNING: Are you sure you want to reset all progress? This will clear all stars and all saved solutions!");
		OutputWriteLine();
		OutputWriteLine("To confirm that you wish to reset all progress, declare a Boolean with the name \"reset\" and a value of true, and run your code.");
		OutputWriteLine("If you've changed your mind, hit \"Cancel\"");
	}

	public void CancelReset(bool quiet = false)
	{
		_resetInitiated = false;
		if (!quiet)
			OutputClear();
	}

	private void ResetIfConditionsMet()
	{
		if (!_resetInitiated)
			return;
		if (Frame.Stack == null)
			return;
		if (Frame.Stack.Count != 1)
			return;
		Scope scope = Frame.Stack.Peek();
		if (scope.DeclaredVariables.Count != 1)
			return;
		Variable variable = scope.DeclaredVariables[0];
		if (variable._VarType != VarType.@bool)
			return;
		if (variable.Name != "reset")
			return;
		bool? value = (bool?)variable.Value;
		if (value != true)
			return;
		_ = ResetSaveAsync();
		CancelReset();
		OutputWriteLine("All progress cleared.");
	}

	public void OnActualSolutionPressed()
	{
		OnEditPressed();
		if (_viewingSolution)
		{
			_viewingSolution = false;
			OnLevelPressed(_currentLevel);
			return;
		}
		_viewingSolution = true;
	}

	public void OutputWriteLine(object message) => _outputText += message + "\n";

	public void OutputWriteLine() => _outputText += "\n";

	public void OutputWrite(object message) => _outputText += message;

	public void OutputClear() => _outputText = string.Empty;

	private void DisplayFrame()
	{
		OutputClear();
		OutputWriteLine(Frame);
		DisplayStack(Frame.Stack, Frame.ActiveLoops, Frame.ActiveForHeaders);
		DisplayHeap(Frame.Heap);
	}

	private void DisplayStack(Stack<Scope>? stack, Stack<int>? activeLoops, Stack<int>? activeForHeaders)
	{
		ClearStack();
		if (stack == null || activeLoops == null || activeForHeaders == null)
			return;
		Scope[] scopes = [..stack];
		for (int i = scopes.Length - 1; i >= 0; i--)
		{
			Scope scope = scopes[i];
			int antiIndex = scopes.Length - 1 - i;
			bool scopeEndIsActiveForHeader = activeForHeaders.Contains(antiIndex + 1);
			bool previousScopeEndIsActiveForHeader = activeForHeaders.Contains(antiIndex);
			bool scopeEndIsActiveLoop = activeLoops.Contains(antiIndex + 1);
			string separatorColor = (scopeEndIsActiveForHeader, previousScopeEndIsActiveForHeader, scopeEndIsActiveLoop) switch
			{
				(true, _, _) => "white",
				(false, true, _) => "black",
				(false, false, true) => "white",
				_ => "rgb(100, 100, 100)"
			};
			for (int j = 0; j < scope.DeclaredVariables.Count - 1; j++)
				PushToStack(scope.DeclaredVariables[j], "inherit");
			if (scope.DeclaredVariables.Count > 0)
			{
				if (i == 0)
					separatorColor = "inherit";
				PushToStack(scope.DeclaredVariables[^1], separatorColor);
			}
		}
	}

	private void PushToStack(Variable variable, string separatorColor)
	=> _stackVariables.Add(new(separatorColor, VarInfo.New(variable), variable.Name!, StackVarInfo.GetFontSize(variable.Name!.Length)));

	private void ClearStack() => _stackVariables.Clear();

	private void ClearHeap()
	{
		_heapCapacity = 50;
		_heapVariables.Clear();
	}

	private void DisplayHeap(Heap? heap)
	{
		if (heap == null)
		{
			ClearHeap();
			return;
		}
		_heapCapacity = heap.Size;
		_heapVariables.Clear();
		foreach (Variable? variable in heap)
		{
			if (variable == null || variable._VarType == null)
			{
				_heapVariables.Add(null);
				continue;
			}
			_heapVariables.Add(VarInfo.New(variable));
		}
	}
}